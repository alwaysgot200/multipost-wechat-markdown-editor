# 核心编辑功能

<cite>
**本文档引用的文件**   
- [CodemirrorEditor.vue](file://apps/web/src/views/CodemirrorEditor.vue)
- [editor.ts](file://apps/web/src/stores/editor.ts)
- [render.ts](file://apps/web/src/stores/render.ts)
- [markdown.ts](file://packages/shared/src/editor/markdown.ts)
- [renderer-impl.ts](file://packages/core/src/renderer/renderer-impl.ts)
- [katex.ts](file://packages/core/src/extensions/katex.ts)
- [plantuml.ts](file://packages/core/src/extensions/plantuml.ts)
- [footnotes.ts](file://packages/core/src/extensions/footnotes.ts)
- [languages.ts](file://packages/core/src/utils/languages.ts)
- [file.ts](file://apps/web/src/utils/file.ts)
</cite>

## 目录
1. [简介](#简介)
2. [编辑器集成与用户交互](#编辑器集成与用户交互)
3. [状态管理机制](#状态管理机制)
4. [@md/core渲染引擎解析](#mdcore渲染引擎解析)
5. [数据流与渲染流程](#数据流与渲染流程)
6. [性能优化策略](#性能优化策略)
7. [扩展功能实现](#扩展功能实现)
8. [代码示例与API调用](#代码示例与api调用)

## 简介
本项目实现了一个功能丰富的微信Markdown编辑器，其核心功能围绕CodeMirror 6编辑器与自定义渲染引擎的深度集成。系统通过Vue 3的组合式API和Pinia状态管理，构建了一个响应式的编辑环境，支持实时预览、语法高亮、多种Markdown扩展语法（如LaTeX、流程图、脚注等）以及多平台图片上传。整体架构分为前端编辑层、状态管理层和后端渲染层，确保了编辑体验的流畅性和输出内容的高质量。

## 编辑器集成与用户交互

项目通过`@codemirror/view`和`@codemirror/state`包将CodeMirror 6深度集成到Vue组件中。在`CodemirrorEditor.vue`中，通过`EditorView`类创建编辑器实例，并利用`markdownSetup`函数配置了完整的Markdown编辑环境。该环境包含了语法高亮、括号匹配、历史记录、搜索替换等基础功能。

快捷键绑定通过`markdownKeymap`函数实现，它定义了一套与微信公众号编辑习惯相符的快捷键，例如`Mod-b`加粗、`Mod-i`斜体、`Mod-k`插入链接，以及`Mod-1`到`Mod-6`快速插入各级标题。这些快捷键通过CodeMirror的`keymap`扩展系统注册，确保了高效的键盘操作体验。

实时同步预览功能通过监听编辑器的滚动事件实现。`leftAndRightScroll`函数建立了编辑区与预览区的滚动同步关系，当用户在任一区域滚动时，另一区域会根据内容比例自动滚动到对应位置，极大地提升了长文档编辑的体验。

**Section sources**
- [CodemirrorEditor.vue](file://apps/web/src/views/CodemirrorEditor.vue#L1-L870)
- [markdown.ts](file://packages/shared/src/editor/markdown.ts#L1-L133)

## 状态管理机制

项目采用Pinia进行状态管理，核心是`editor`和`render`两个store。

`editor` store（`editor.ts`）负责管理CodeMirror编辑器实例及其基本操作。它通过`ref<EditorView | null>`存储编辑器视图实例，并暴露了`getContent`、`getSelection`、`replaceSelection`、`insertAtCursor`等方法，为上层组件提供了统一的编辑器操作接口。这些方法封装了CodeMirror复杂的`dispatch`和`state`操作，简化了业务逻辑。

`render` store（`render.ts`）则负责Markdown的渲染、HTML输出和元数据提取。它维护了`output`（渲染后的HTML）、`readingTime`（阅读统计）和`titleList`（标题列表）等状态。其核心是`initRendererInstance`和`render`方法。`initRendererInstance`在组件挂载时初始化`@md/core`的渲染器实例，而`render`方法则接收编辑器内容，调用渲染器进行转换，并将结果更新到`output`状态，触发预览区的重新渲染。

两个store通过`editorRefresh`函数协同工作，当编辑器内容变化时，该函数被调用，触发`render` store的`render`方法，从而实现“编辑-渲染-预览”的闭环。

**Section sources**
- [editor.ts](file://apps/web/src/stores/editor.ts#L1-L91)
- [render.ts](file://apps/web/src/stores/render.ts#L1-L110)

## @md/core渲染引擎解析

`@md/core`是项目的核心渲染引擎，基于`marked`库进行深度扩展，以支持微信公众号的特殊需求和丰富的Markdown扩展语法。

### 核心架构
渲染引擎的入口是`renderer-impl.ts`中的`initRenderer`函数。它创建了一个`marked`的`RendererObject`，并重写了所有HTML标签的生成逻辑。关键特性是`styledContent`函数，它不直接输出内联样式，而是为每个HTML元素添加特定的CSS类名（如`md-blockquote`、`md-blockquote-p`），这使得样式可以通过外部CSS文件进行统一管理和主题化，符合现代Web开发的最佳实践。

### 扩展语法支持
引擎通过`marked.use()`方法加载了多个自定义扩展，这些扩展位于`packages/core/src/extensions/`目录下。

#### 脚注 (Footnotes)
`footnotes.ts`实现了标准的脚注语法。它通过两个`marked`扩展：`footnoteDef`（块级）和`footnoteRef`（行内）来解析`[^1]: ...`和`[^1]`。解析时，它使用一个`Map`来存储脚注ID与内容的映射，并在渲染时生成带有上标链接和底部引用列表的HTML。

#### LaTeX (KaTeX)
`katex.ts`扩展支持LaTeX数学公式。它定义了四种语法：`$...$`（行内）、`$$...$$`（块级）、`\(...\)`（行内）和`\[...\]`（块级）。解析器通过正则表达式匹配这些模式，并调用全局的`MathJax`库将LaTeX代码转换为SVG矢量图，然后嵌入到HTML中。这确保了数学公式的高质量显示。

#### 流程图 (PlantUML)
`plantuml.ts`扩展支持使用PlantUML DSL绘制流程图。它会识别```plantuml ... ```代码块，将UML代码通过特定的Deflate压缩和Base64编码算法处理，然后生成指向PlantUML服务器的图片URL。对于微信公众号这种不支持外链图片的环境，它还支持`inlineSvg`选项，通过异步请求将SVG内容内联到HTML中。

**Section sources**
- [renderer-impl.ts](file://packages/core/src/renderer/renderer-impl.ts#L1-L387)
- [katex.ts](file://packages/core/src/extensions/katex.ts#L1-L163)
- [plantuml.ts](file://packages/core/src/extensions/plantuml.ts#L1-L290)
- [footnotes.ts](file://packages/core/src/extensions/footnotes.ts#L1-L90)

## 数据流与渲染流程

从用户输入到最终渲染输出的数据流是一个清晰的单向数据流：

```mermaid
flowchart TD
A[用户输入] --> B[CodeMirror]
B --> C[editor store]
C --> D[render store]
D --> E[marked解析]
E --> F[@md/core处理扩展]
F --> G[渲染HTML]
G --> H[预览区显示]
```

**Diagram sources**
- [CodemirrorEditor.vue](file://apps/web/src/views/CodemirrorEditor.vue#L1-L870)
- [editor.ts](file://apps/web/src/stores/editor.ts#L1-L91)
- [render.ts](file://apps/web/src/stores/render.ts#L1-L110)
- [renderer-impl.ts](file://packages/core/src/renderer/renderer-impl.ts#L1-L387)

1.  **用户输入**: 用户在CodeMirror编辑器中输入Markdown文本。
2.  **CodeMirror**: 编辑器捕获用户的输入事件。
3.  **editor store**: 通过`EditorView.updateListener`监听`docChanged`事件，当文档变化时，触发`editorRefresh`函数。
4.  **render store**: `editorRefresh`函数调用`renderStore.render()`方法，并传入当前编辑器内容。
5.  **marked解析**: `render`方法内部调用`renderMarkdown`函数，该函数使用`marked`库将Markdown字符串解析为初步的HTML字符串。
6.  **@md/core处理扩展**: 在解析过程中，`@md/core`的各个扩展（如`MDKatex`、`markedPlantUML`）介入，将特定的语法（如`$$...$$`、```plantuml）转换为对应的HTML结构（如SVG、图片标签）。
7.  **渲染HTML**: 初步的HTML经过`postProcessHtml`后处理，添加阅读时间、目录等元信息，并最终赋值给`renderStore`的`output`状态。
8.  **预览区显示**: `output`状态的变更触发Vue的响应式更新，预览区的`v-html`指令将新的HTML内容渲染到DOM中，完成整个流程。

## 性能优化策略

项目采用了多种策略来优化性能，确保在处理大型文档时依然流畅。

### 防抖渲染
最核心的优化是防抖（Debounce）。在`CodemirrorEditor.vue`中，`EditorView.updateListener`的`docChanged`回调里，使用`setTimeout`对`editorRefresh`调用进行了300毫秒的防抖。这意味着用户在连续输入时，渲染操作不会被频繁触发，只有当用户停止输入约300毫秒后，才会执行一次渲染，极大地减少了不必要的计算和DOM更新。

### 增量更新与懒加载
*   **代码高亮**: 对于未注册的编程语言，系统不会在初始渲染时加载其语法高亮文件。`renderer-impl.ts`中的`code`渲染器会为这些代码块添加`data-language-pending`属性。渲染完成后，`highlightPendingBlocks`函数会遍历所有待处理的代码块，动态加载对应的`highlight.js`语言包并进行高亮。这避免了加载所有语言包带来的巨大开销。
*   **Mermaid图表**: `code`渲染器在检测到`mermaid`代码块时，会设置一个`setTimeout`，在下一个事件循环中调用`mermaid.run()`来渲染图表。这确保了主渲染流程不会被复杂的图表生成阻塞。

### 可能的瓶颈与解决方案
*   **瓶颈**: 大型文档的初始渲染和防抖后的渲染仍可能造成界面卡顿。
*   **解决方案**: 可以进一步优化，例如将`marked`的解析过程移至Web Worker中执行，完全避免阻塞主线程。此外，对于包含大量图片或复杂图表的文档，可以实现虚拟滚动（Virtual Scrolling）来优化预览区的渲染性能。

**Section sources**
- [CodemirrorEditor.vue](file://apps/web/src/views/CodemirrorEditor.vue#L491-L522)
- [languages.ts](file://packages/core/src/utils/languages.ts#L214-L238)
- [renderer-impl.ts](file://packages/core/src/renderer/renderer-impl.ts#L211-L225)

## 扩展功能实现

项目不仅支持核心编辑功能，还集成了丰富的扩展功能。

### 图片上传
`file.ts`文件实现了多平台图片上传。用户可以通过拖拽、粘贴或弹窗上传图片。系统根据用户配置的图床（如GitHub、Gitee、七牛云、腾讯云COS等），调用相应的API将图片上传，并将返回的URL插入到Markdown中。例如，`ghFileUpload`函数使用GitHub API，`qiniuUpload`函数使用七牛云的`qiniu-js` SDK。

### 主题系统
项目采用基于CSS变量的主题系统。`theme` store管理主题相关的配置（如是否使用Mac风格代码块、是否显示行号）。这些配置通过CSS变量注入到页面的`<style>`标签中，`@md/core`的渲染器则生成带有特定类名的HTML，最终由CSS文件根据变量值来决定具体的样式表现，实现了高度的可定制性。

**Section sources**
- [file.ts](file://apps/web/src/utils/file.ts#L1-L641)
- [CodemirrorEditor.vue](file://apps/web/src/views/CodemirrorEditor.vue#L292-L371)

## 代码示例与API调用

### 调用renderMarkdown函数
`renderMarkdown`函数是`@md/core/utils`导出的工具函数，用于执行核心的Markdown到HTML的转换。其调用方式如下：

```typescript
import { renderMarkdown } from '@md/core/utils';
import { initRenderer } from '@md/core';

// 1. 初始化渲染器
const renderer = initRenderer({ isShowLineNumber: true });

// 2. 调用renderMarkdown
const { html, readingTime } = renderMarkdown('# Hello World\nThis is a test.', renderer);

// 3. html变量即为渲染后的HTML字符串
console.log(html); // <h1 class="h1">Hello World</h1><p class="p">This is a test.</p>
```

### 监听编辑器内容变化
监听编辑器内容的变化是通过CodeMirror的`updateListener`扩展实现的。在创建`EditorState`时，将其作为扩展之一：

```typescript
import { EditorState, EditorView } from '@codemirror/view';

const state = EditorState.create({
  doc: initialContent,
  extensions: [
    // ... 其他扩展
    EditorView.updateListener.of((update) => {
      if (update.docChanged) {
        const newValue = update.state.doc.toString();
        console.log('内容已更改:', newValue);
        // 在这里调用 editorRefresh 或其他处理函数
      }
    }),
  ],
});

const view = new EditorView({ state, parent: document.body });
```

此监听器会在每次文档内容发生变化时被调用，是触发后续渲染流程的关键。

**Section sources**
- [utils/index.ts](file://apps/web/src/utils/index.ts#L38)
- [renderer-impl.ts](file://packages/core/src/renderer/renderer-impl.ts#L112-L387)
- [CodemirrorEditor.vue](file://apps/web/src/views/CodemirrorEditor.vue#L506-L522)
# 构建脚本与自动化流程

<cite>
**本文档中引用的文件**   
- [build-standalone.sh](file://scripts/build-standalone.sh)
- [build-static.sh](file://scripts/build-static.sh)
- [build-multiarch.sh](file://scripts/build-multiarch.sh)
- [build-base-image.sh](file://scripts/build-base-image.sh)
- [build-nginx.sh](file://scripts/build-nginx.sh)
- [Dockerfile.base](file://docker/latest/Dockerfile.base)
- [Dockerfile.standalone](file://docker/latest/Dockerfile.standalone)
- [Dockerfile.nginx](file://docker/latest/Dockerfile.nginx)
- [Dockerfile.static](file://docker/latest/Dockerfile.static)
- [vite.config.ts](file://apps/web/vite.config.ts)
- [wxt.config.ts](file://apps/web/wxt.config.ts)
- [netlify.toml](file://apps/web/netlify.toml)
- [.env](file://docker/latest/.env)
- [package.json](file://package.json)
- [docker-compose-build.yml](file://docker/docker-compose-build.yml)
</cite>

## 目录
1. [项目结构](#项目结构)
2. [构建脚本分析](#构建脚本分析)
3. [Docker镜像构建流程](#docker镜像构建流程)
4. [Vite与WXT构建配置](#vite与wxt构建配置)
5. [CI/CD流程整合](#cicd流程整合)
6. [构建调试与常见问题](#构建调试与常见问题)
7. [性能优化建议](#性能优化建议)

## 项目结构

该项目采用多包（monorepo）架构，通过pnpm工作区管理多个应用和包。核心构建流程集中在`scripts`目录下的构建脚本和`docker`目录的Docker配置中。

```mermaid
graph TD
A[项目根目录] --> B[apps]
A --> C[packages]
A --> D[docker]
A --> E[scripts]
A --> F[packages]
B --> B1[web]
B --> B2[vscode]
B --> B3[utools]
C --> C1[core]
C --> C2[shared]
C --> C3[config]
C --> C4[md-cli]
D --> D1[latest]
D --> D2[Dockerfile]
D --> D3[nginx.conf]
E --> E1[build-standalone.sh]
E --> E2[build-static.sh]
E --> E3[build-multiarch.sh]
E --> E4[build-base-image.sh]
E --> E5[build-nginx.sh]
```

**Diagram sources**
- [package.json](file://package.json#L50-L58)
- [pnpm-workspace.yaml](file://pnpm-workspace.yaml#L1-L3)

**Section sources**
- [package.json](file://package.json)
- [pnpm-workspace.yaml](file://pnpm-workspace.yaml)

## 构建脚本分析

项目提供了一系列构建脚本，用于生成不同形态的部署产物。这些脚本通过遍历`docker`目录下的版本文件夹，读取环境变量并调用Docker构建命令。

### 构建脚本类型

```mermaid
graph TD
A[构建脚本] --> B[build-base-image.sh]
A --> C[build-standalone.sh]
A --> D[build-nginx.sh]
A --> E[build-static.sh]
A --> F[build-multiarch.sh]
B --> G[生成基础静态资源镜像]
C --> H[生成独立运行的Go应用镜像]
D --> I[生成Nginx服务镜像]
E --> J[生成纯静态网站镜像]
F --> K[多架构镜像构建与推送]
```

**Diagram sources**
- [build-standalone.sh](file://scripts/build-standalone.sh)
- [build-static.sh](file://scripts/build-static.sh)
- [build-multiarch.sh](file://scripts/build-multiarch.sh)
- [build-base-image.sh](file://scripts/build-base-image.sh)
- [build-nginx.sh](file://scripts/build-nginx.sh)

#### 环境变量加载机制

所有构建脚本都采用相同的环境变量加载模式，通过`set -a`和`set +a`命令将`.env`文件中的变量导入shell环境。

```mermaid
flowchart TD
Start([开始]) --> ReadEnv["读取 .env 文件"]
ReadEnv --> LoadEnv["使用 'set -a' 加载变量"]
LoadEnv --> Build["执行 Docker 构建"]
Build --> End([结束])
style Start fill:#f9f,stroke:#333
style End fill:#f9f,stroke:#333
```

**Diagram sources**
- [build-standalone.sh](file://scripts/build-standalone.sh#L12-L14)
- [build-static.sh](file://scripts/build-static.sh#L12-L14)

**Section sources**
- [build-standalone.sh](file://scripts/build-standalone.sh#L1-L25)
- [build-static.sh](file://scripts/build-static.sh#L1-L25)
- [docker/latest/.env](file://docker/latest/.env)

## Docker镜像构建流程

项目通过多阶段Docker构建策略，生成不同用途的镜像。构建流程分为基础资源构建、独立应用构建、Nginx服务构建和静态网站构建。

### 多阶段构建流程

```mermaid
graph TD
A[基础构建阶段] --> |生成静态资源| B[基础镜像]
B --> |作为依赖| C[独立应用构建]
B --> |作为依赖| D[Nginx构建]
B --> |作为依赖| E[静态网站构建]
C --> F[包含Go编译的独立应用]
D --> G[基于Nginx的Web服务]
E --> H[基于轻量级HTTP服务器的静态网站]
```

**Diagram sources**
- [Dockerfile.base](file://docker/latest/Dockerfile.base)
- [Dockerfile.standalone](file://docker/latest/Dockerfile.standalone)
- [Dockerfile.nginx](file://docker/latest/Dockerfile.nginx)
- [Dockerfile.static](file://docker/latest/Dockerfile.static)

### 基础镜像构建流程

```mermaid
sequenceDiagram
participant Script as 构建脚本
participant Docker as Docker引擎
participant Node as Node容器
participant Scratch as Scratch容器
Script->>Docker : 调用docker build
Docker->>Node : 启动node : 22-alpine容器
Node->>Node : 安装依赖并构建前端
Node->>Node : 执行pnpm web build : h5-netlify
Node->>Scratch : 复制构建产物到scratch容器
Scratch->>Docker : 生成基础镜像
Docker->>Script : 完成镜像构建
```

**Diagram sources**
- [build-base-image.sh](file://scripts/build-base-image.sh)
- [Dockerfile.base](file://docker/latest/Dockerfile.base)

**Section sources**
- [build-base-image.sh](file://scripts/build-base-image.sh#L1-L25)
- [Dockerfile.base](file://docker/latest/Dockerfile.base#L1-L15)

### 独立应用构建流程

```mermaid
sequenceDiagram
participant Script as 构建脚本
participant Docker as Docker引擎
participant Assets as 基础资源镜像
participant GoBuilder as Go构建容器
participant Final as 最终运行容器
Script->>Docker : 调用docker build
Docker->>Assets : 拉取基础资源镜像
Docker->>GoBuilder : 启动Go构建容器
GoBuilder->>GoBuilder : 复制前端资源
GoBuilder->>GoBuilder : 复制Go服务代码
GoBuilder->>GoBuilder : 编译Go应用
GoBuilder->>GoBuilder : 使用UPX压缩二进制
GoBuilder->>Final : 复制压缩后的二进制
Final->>Docker : 生成独立应用镜像
Docker->>Script : 完成镜像构建
```

**Diagram sources**
- [build-standalone.sh](file://scripts/build-standalone.sh)
- [Dockerfile.standalone](file://docker/latest/Dockerfile.standalone)

**Section sources**
- [build-standalone.sh](file://scripts/build-standalone.sh#L1-L25)
- [Dockerfile.standalone](file://docker/latest/Dockerfile.standalone#L1-L23)

### 多架构构建与推送流程

```mermaid
flowchart TD
Start([开始多架构构建]) --> Scan["扫描 docker 目录"]
Scan --> CheckEnv["检查 .env 文件存在性"]
CheckEnv --> LoadEnv["加载环境变量"]
LoadEnv --> BuildBase["构建基础镜像"]
BuildBase --> BuildNginx["构建Nginx镜像"]
BuildNginx --> BuildStandalone["构建独立应用镜像"]
BuildStandalone --> BuildStatic["构建静态网站镜像"]
BuildStatic --> Push["推送所有镜像到仓库"]
Push --> End([完成])
style Start fill:#4CAF50,stroke:#333
style End fill:#4CAF50,stroke:#333
```

**Diagram sources**
- [build-multiarch.sh](file://scripts/build-multiarch.sh)
- [docker-compose-build.yml](file://docker/docker-compose-build.yml)

**Section sources**
- [build-multiarch.sh](file://scripts/build-multiarch.sh#L1-L88)

## Vite与WXT构建配置

前端构建由Vite驱动，同时支持WXT扩展开发构建，通过环境变量控制不同构建目标。

### Vite构建配置分析

```mermaid
classDiagram
class ViteConfig {
+base : string
+define : object
+envPrefix : array
+plugins : array
+resolve : object
+css : object
+build : object
}
class Plugins {
+vue()
+tailwindcss()
+vueDevTools()
+nodePolyfills()
+VitePluginRadar()
+visualizer()
+AutoImport()
+Components()
+utoolsLocalAssetsPlugin()
}
class BuildOptions {
+rollupOptions : object
+chunkFileNames : string
+entryFileNames : string
+assetFileNames : string
+manualChunks() : function
}
ViteConfig --> Plugins : "包含"
ViteConfig --> BuildOptions : "包含"
```

**Diagram sources**
- [vite.config.ts](file://apps/web/vite.config.ts)

**Section sources**
- [vite.config.ts](file://apps/web/vite.config.ts#L1-L92)
- [package.json](file://apps/web/package.json#L8-L29)

### WXT扩展构建配置

```mermaid
sequenceDiagram
participant WXT as WXT构建系统
participant Vite as Vite配置
participant Manifest as Chrome扩展清单
participant Build as 构建产物
WXT->>Vite : 加载vite.config.ts
Vite-->>WXT : 返回Vite配置
WXT->>Manifest : 生成扩展清单
Manifest-->>WXT : 返回清单配置
WXT->>WXT : 过滤掉分析插件
WXT->>WXT : 设置基础路径为根目录
WXT->>Build : 执行构建
Build-->>WXT : 生成扩展包
```

**Diagram sources**
- [wxt.config.ts](file://apps/web/wxt.config.ts)

**Section sources**
- [wxt.config.ts](file://apps/web/wxt.config.ts#L1-L102)

## CI/CD流程整合

从源码到可部署产物的完整CI/CD流程整合了多种部署目标，包括Docker镜像、Netlify静态站点等。

### 完整CI/CD流程

```mermaid
flowchart LR
A[源码提交] --> B[安装依赖]
B --> C[执行构建脚本]
C --> D{构建目标}
D --> E[基础资源镜像]
D --> F[独立应用镜像]
D --> G[Nginx服务镜像]
D --> H[静态网站镜像]
E --> I[推送Docker仓库]
F --> I
G --> I
H --> J[部署到Netlify]
J --> K[生产环境]
I --> K
```

**Diagram sources**
- [netlify.toml](file://apps/web/netlify.toml)
- [Dockerfile](file://docker/Dockerfile)
- [build-multiarch.sh](file://scripts/build-multiarch.sh)

### Netlify部署配置

```mermaid
graph TB
    NetlifyConfig["Netlify 配置<br/>━━━━━━━━━━<br/>netlify.toml"]
    
    BuildConfig["构建配置<br/>━━━━━━━━━━<br/>command:<br/>pnpm run build:h5-netlify<br/><br/>publish: dist"]
    
    RedirectsConfig["重定向配置<br/>━━━━━━━━━━<br/>from: /*<br/>to: /index.html<br/>status: 200"]
    
    NetlifyConfig --> BuildConfig
    NetlifyConfig --> RedirectsConfig
    
    style NetlifyConfig fill:#e1f5ff,stroke:#0284c7,stroke-width:2px
    style BuildConfig fill:#dcfce7,stroke:#16a34a,stroke-width:2px
    style RedirectsConfig fill:#fef3c7,stroke:#f59e0b,stroke-width:2px
```

**Diagram sources**
- [netlify.toml](file://apps/web/netlify.toml)

**Section sources**
- [netlify.toml](file://apps/web/netlify.toml#L1-L10)
- [package.json](file://apps/web/package.json#L13-L14)

## 构建调试与常见问题

### 脚本调试方法

```mermaid
flowchart TD
A[调试构建脚本] --> B[启用bash调试模式]
B --> C[使用set -x命令]
C --> D[检查环境变量]
D --> E[验证Docker构建参数]
E --> F[查看详细构建日志]
F --> G[逐步执行脚本]
```

**Section sources**
- [build-standalone.sh](file://scripts/build-standalone.sh)
- [build-multiarch.sh](file://scripts/build-multiarch.sh)

### 常见执行错误及解决方案

| 问题类型 | 错误表现 | 解决方案 |
|---------|--------|---------|
| 权限不足 | `Permission denied` | 确保脚本具有执行权限 `chmod +x script.sh` |
| 依赖缺失 | `command not found` | 安装必需工具：Docker, pnpm, buildx |
| 环境变量缺失 | 变量为空或默认值 | 检查`.env`文件是否存在且格式正确 |
| Docker构建失败 | 构建阶段错误 | 检查Dockerfile语法和构建上下文 |
| 多架构构建失败 | 平台不支持 | 确保Docker配置了buildx builder |

**Section sources**
- [build-multiarch.sh](file://scripts/build-multiarch.sh#L3-L88)
- [docker/latest/.env](file://docker/latest/.env)

## 性能优化建议

### 构建性能优化策略

```mermaid
graph TD
A[构建性能优化] --> B[使用缓存]
A --> C[并行构建]
A --> D[减少层数量]
A --> E[优化依赖安装]
A --> F[压缩最终产物]
B --> B1[利用Docker层缓存]
C --> C1[使用buildx并行构建多架构]
D --> D1[合并RUN指令]
E --> E1[使用pnpm减少安装时间]
F --> F1[使用UPX压缩Go二进制]
```

**Section sources**
- [Dockerfile.base](file://docker/latest/Dockerfile.base)
- [Dockerfile.standalone](file://docker/latest/Dockerfile.standalone)
- [build-multiarch.sh](file://scripts/build-multiarch.sh)

### 具体优化措施

1. **Docker层优化**：在`Dockerfile.base`中，将相关的命令合并到单个RUN指令中，减少镜像层数量
2. **依赖缓存**：利用Docker构建缓存机制，避免重复下载和安装npm包
3. **二进制压缩**：在`Dockerfile.standalone`中使用UPX工具压缩Go编译的二进制文件
4. **分块构建**：Vite配置中通过`manualChunks`将第三方库分离，优化前端加载性能
5. **多架构并行**：`build-multiarch.sh`脚本使用buildx同时构建amd64和arm64架构镜像

**Section sources**
- [Dockerfile.base](file://docker/latest/Dockerfile.base#L10)
- [Dockerfile.standalone](file://docker/latest/Dockerfile.standalone#L16)
- [vite.config.ts](file://apps/web/vite.config.ts#L70-L85)
- [build-multiarch.sh](file://scripts/build-multiarch.sh#L7-L88)